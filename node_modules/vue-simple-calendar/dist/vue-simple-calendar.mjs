var $e = Object.defineProperty;
var Te = (e, n, t) => n in e ? $e(e, n, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[n] = t;
var Y = (e, n, t) => (Te(e, typeof n != "symbol" ? n + "" : n, t), t);
import { defineComponent as ie, reactive as Ye, computed as m, watch as Ae, openBlock as v, createElementBlock as h, normalizeClass as S, unref as u, renderSlot as C, createElementVNode as y, createCommentVNode as se, Fragment as A, renderList as w, toDisplayString as M, withModifiers as P, normalizeStyle as oe, createTextVNode as le } from "vue";
const H = () => E(new Date()), we = (e, n, t) => {
  switch (n) {
    case "year":
      return new Date(e.getFullYear(), 0);
    case "month":
      return new Date(e.getFullYear(), e.getMonth());
    case "week":
      return G(e, t);
    default:
      return e;
  }
}, We = (e) => [...Array(7)].map((n, t) => L(e, t)), L = (e, n) => new Date(e.getFullYear(), e.getMonth(), e.getDate() + n, e.getHours(), e.getMinutes(), e.getSeconds()), G = (e, n) => L(e, (n - e.getDay() - 7) % -7), He = (e, n) => L(G(e, n), 7), W = (e) => new Date(e.getFullYear(), e.getMonth()), Ne = (e) => Math.ceil(e.getDate() / 7), Be = (e, n, t) => new Date(e.getFullYear() + (n == "year" ? t : 0), e.getMonth() + (n == "month" ? t : 0), e.getDate() + (n == "week" ? t * 7 : 0)), Q = (e) => ("0" + String(e.getMonth() + 1)).slice(-2), J = (e) => ("0" + String(e.getDate())).slice(-2), de = (e) => e.getFullYear() + "-" + Q(e), Ee = (e) => de(e) + "-" + J(e), xe = (e) => Q(e) + "-" + J(e), Ue = (e, n, t) => {
  if (e.getHours() === 0 && e.getMinutes() === 0 && e.getSeconds() === 0)
    return "";
  if (!x()) {
    var i = new Date().getTimezoneOffset() * 6e4;
    return new Date(e.getTime() - i).toISOString().slice(11, 16);
  }
  return e.toLocaleTimeString(n, t);
}, Re = (e, n, t, i) => {
  const c = e.getFullYear() === n.getFullYear(), b = ce(e, n), k = !(t === "year") && !(t === "month");
  let g = [];
  return g.push(i[e.getMonth()]), k && (g.push(" "), g.push(e.getDate())), c || (g.push(k ? ", " : " "), g.push(e.getFullYear())), !b || !c ? (g.push(" – "), b || g.push(i[n.getMonth()]), k && g.push(" ")) : k && g.push(" – "), k ? (g.push(n.getDate()), g.push(", ")) : g.push(" "), g.push(n.getFullYear()), g.join("");
}, ue = (e, n) => {
  const t = Date.UTC(n.getFullYear(), n.getMonth(), n.getDate()), i = Date.UTC(e.getFullYear(), e.getMonth(), e.getDate());
  return (t - i) / 864e5;
}, Ve = (e, n) => !!e && !!n && ue(e, n) === 0, ze = (e, n) => !!e && !!n && e.getTime() === n.getTime(), ce = (e, n) => !!e && !!n && e.getFullYear() === n.getFullYear() && e.getMonth() === n.getMonth(), je = (e) => W(e) < W(H()), qe = (e) => W(e) > W(H()), Ge = (e) => E(e) > H(), Qe = (e) => E(e) < H(), Je = (e) => e.getMonth() !== L(e, 7).getMonth(), Ke = (e) => e.getMonth() !== L(e, 1).getMonth(), ge = (e) => {
  let n = [...Array(7)].map((t) => 0);
  return e.split(/\D/, 7).forEach((t, i) => n[i] = Number(t)), n[1]--, new Date(n[0], n[1], n[2], n[3], n[4], n[5], n[6]);
}, q = (e) => typeof e == "string" ? ge(e) : new Date(e), E = (e) => {
  const n = new Date(e);
  return n.setHours(0, 0, 0, 0), n;
}, Xe = (e) => e.substring(0, 2), x = () => typeof Intl < "u", Ze = (e, n) => {
  if (!x())
    return [...Array(12)].map((i) => "");
  const t = new Intl.DateTimeFormat(e, { month: n });
  return [...Array(12)].map((i, c) => t.format(new Date(2017, c, 1)));
}, _e = (e, n, t) => {
  if (!x())
    return [...Array(7)].map((c) => "");
  const i = new Intl.DateTimeFormat(e, { weekday: n });
  return [...Array(7)].map((c, b) => i.format(new Date(2017, 0, (b + 1 + t) % 7)));
}, et = () => typeof navigator > "u" ? "unk" : (navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language).toLowerCase(), tt = (e, n) => {
  const t = e.classes ? [...e.classes] : [];
  return n && t.push("isHovered"), {
    originalItem: e,
    startDate: q(e.startDate),
    // For an item without an end date, the end date is the start date
    endDate: q(e.endDate || e.startDate),
    classes: t,
    // Items without a title are untitled
    title: e.title || "Untitled",
    // An ID is *required*. Auto-generating leads to weird bugs because these are used as keys and passed in items
    id: e.id,
    // Pass the URL along
    url: e.url,
    // Use the item's title as the tooltip if the tooltip is undefined or null (but not if it is blank -- use blank to essentially disable tooltips)
    tooltip: e.tooltip ?? e.title
  };
}, r = {
  addDays: L,
  beginningOfMonth: W,
  beginningOfPeriod: we,
  beginningOfWeek: G,
  dateOnly: E,
  dayDiff: ue,
  daysOfWeek: We,
  endOfWeek: He,
  formattedPeriod: Re,
  formattedTime: Ue,
  fromIsoStringToLocalDate: ge,
  getDefaultBrowserLocale: et,
  getFormattedMonthNames: Ze,
  getFormattedWeekdayNames: _e,
  incrementPeriod: Be,
  instanceOfMonth: Ne,
  isFutureMonth: qe,
  isInFuture: Ge,
  isInPast: Qe,
  isLastDayOfMonth: Ke,
  isLastInstanceOfMonth: Je,
  isoMonthDay: xe,
  isoYearMonth: de,
  isoYearMonthDay: Ee,
  isPastMonth: je,
  isSameDate: Ve,
  isSameDateTime: ze,
  isSameMonth: ce,
  languageCode: Xe,
  normalizeItem: tt,
  paddedDay: J,
  paddedMonth: Q,
  supportsIntl: x,
  today: H,
  toLocalDate: q
};
class at {
  constructor() {
    Y(this, "currentDragItem");
    Y(this, "dateSelectionOrigin");
    Y(this, "currentHoveredItemId", "");
    Y(this, "CalendarMath", r);
  }
}
const nt = { class: "cv-header-days" }, rt = {
  key: 0,
  class: "cv-weeknumber"
}, st = ["aria-multiselectable"], ot = {
  key: 0,
  class: "cv-weeknumber"
}, it = { class: "cv-weekdays" }, lt = ["draggable", "aria-grabbed", "aria-label", "aria-selected", "aria-dropeffect", "onClick", "onDragstart", "onDrop", "onDragover", "onDragenter", "onDragleave"], dt = { class: "cv-day-number" }, ut = ["draggable", "aria-grabbed", "title", "onDragstart", "onMouseenter", "onMouseleave", "onClick", "innerHTML"], ct = ["draggable", "aria-grabbed", "title", "onDragstart", "onMouseenter", "onMouseleave", "onClick"], Pt = /* @__PURE__ */ ie({
  __name: "CalendarView",
  props: {
    showDate: { default: void 0 },
    displayPeriodUom: { default: "month" },
    displayPeriodCount: { default: 1 },
    displayWeekNumbers: { type: Boolean, default: !1 },
    locale: { default: void 0 },
    monthNameFormat: { default: "long" },
    weekdayNameFormat: { default: "short" },
    showTimes: { type: Boolean, default: !1 },
    timeFormatOptions: { default: () => ({}) },
    disablePast: { type: Boolean, default: !1 },
    disableFuture: { type: Boolean, default: !1 },
    enableDateSelection: { type: Boolean, default: !1 },
    selectionStart: { default: void 0 },
    selectionEnd: { default: void 0 },
    enableDragDrop: { type: Boolean, default: !1 },
    startingDayOfWeek: { default: 0 },
    items: { default: () => [] },
    dateClasses: { default: () => ({}) },
    itemTop: { default: "1.4em" },
    itemContentHeight: { default: "1.4em" },
    itemBorderHeight: { default: "2px" },
    periodChangedCallback: { type: Function, default: void 0 },
    currentPeriodLabel: { default: "" },
    currentPeriodLabelIcons: { default: "⇤-⇥" },
    doEmitItemMouseEvents: { type: Boolean, default: !1 },
    enableHtmlTitles: { type: Boolean, default: !0 }
  },
  emits: ["period-changed", "click-date", "click-item", "item-mouseenter", "item-mouseleave", "drag-start", "drag-over-date", "drag-enter-date", "drag-leave-date", "drop-on-date", "date-selection", "date-selection-start", "date-selection-finish"],
  setup(e, { emit: n }) {
    const t = e, i = Ye(new at()), c = m(() => t.locale || r.getDefaultBrowserLocale()), b = m(() => t.showDate ? r.dateOnly(t.showDate) : r.today()), D = m(() => r.beginningOfPeriod(b.value, t.displayPeriodUom, t.startingDayOfWeek)), F = m(
      () => r.addDays(r.incrementPeriod(D.value, t.displayPeriodUom, t.displayPeriodCount), -1)
    ), k = m(() => {
      const a = r.beginningOfWeek(r.beginningOfPeriod(D.value, "year", 0), t.startingDayOfWeek), o = r.beginningOfWeek(D.value, t.startingDayOfWeek);
      return 1 + Math.floor(r.dayDiff(a, o) / 7);
    }), g = m(() => r.beginningOfWeek(D.value, t.startingDayOfWeek)), U = m(() => r.endOfWeek(F.value, t.startingDayOfWeek)), fe = m(() => {
      const a = Math.floor((r.dayDiff(g.value, U.value) + 1) / 7);
      return [...Array(a)].map((o, l) => r.addDays(g.value, l * 7));
    }), R = m(() => r.getFormattedMonthNames(c.value, t.monthNameFormat)), me = m(() => r.getFormattedWeekdayNames(c.value, t.weekdayNameFormat, t.startingDayOfWeek)), V = m(() => t.items ? t.items.map((a) => r.normalizeItem(a, a.id === i.currentHoveredItemId)) : []), z = m(() => r.beginningOfPeriod(r.today(), t.displayPeriodUom, t.startingDayOfWeek)), De = m(
      () => r.addDays(r.incrementPeriod(z.value, t.displayPeriodUom, t.displayPeriodCount), -1)
    ), pe = m(() => r.formattedPeriod(D.value, F.value, t.displayPeriodUom, R.value)), ve = m(() => {
      const a = z.value, o = D.value;
      return t.currentPeriodLabel ? t.currentPeriodLabel === "icons" ? t.currentPeriodLabelIcons[Math.sign(a.getTime() - o.getTime()) + 1] : t.currentPeriodLabel : r.formattedPeriod(a, De.value, t.displayPeriodUom, R.value);
    }), he = m(
      () => ({
        // Dates for UI navigation
        previousYear: O(-12),
        previousPeriod: O(-1),
        nextPeriod: O(1),
        previousFullPeriod: O(-t.displayPeriodCount),
        nextFullPeriod: O(t.displayPeriodCount),
        nextYear: O(12),
        currentPeriod: z.value,
        currentPeriodLabel: ve.value,
        // Dates for header display
        periodStart: D.value,
        periodEnd: F.value,
        // Extra information that could be useful to a custom header
        displayLocale: c.value,
        displayFirstDate: g.value,
        displayLastDate: U.value,
        monthNames: R.value,
        fixedItems: V.value,
        periodLabel: pe.value
      })
    ), be = m(() => ({
      periodStart: D,
      periodEnd: F,
      displayFirstDate: g,
      displayLastDate: U
    }));
    Ae(
      () => be,
      (a) => {
        t.periodChangedCallback && (n("period-changed"), t.periodChangedCallback(a, "watch"));
      },
      { immediate: !0, deep: !0 }
    );
    const ye = (a, o) => {
      t.disablePast && r.isInPast(a) || t.disableFuture && r.isInFuture(a) || n("click-date", a, ee(a, a), o);
    }, K = (a, o) => n("click-item", a, o), $ = (a) => "dow" + (a + t.startingDayOfWeek) % 7, O = (a) => {
      const o = r.incrementPeriod(D.value, t.displayPeriodUom, a), l = r.incrementPeriod(o, t.displayPeriodUom, t.displayPeriodCount);
      return t.disablePast && l <= r.today() || t.disableFuture && o > r.today() ? null : o;
    }, X = (a, o) => {
      i.currentHoveredItemId = a.id, t.doEmitItemMouseEvents && n("item-mouseenter", a, o);
    }, Z = (a, o) => {
      i.currentHoveredItemId = "", t.doEmitItemMouseEvents && n("item-mouseleave", a, o);
    }, Pe = (a, o) => {
      var f, s;
      if (!t.enableDateSelection)
        return !1;
      (f = o.dataTransfer) == null || f.setData("text", a.toString());
      let l = new Image();
      return l.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==", (s = o.dataTransfer) == null || s.setDragImage(l, 10, 10), i.dateSelectionOrigin = a, n("date-selection-start", j(a), o), !0;
    }, _ = (a, o) => {
      var l;
      return t.enableDragDrop ? ((l = o.dataTransfer) == null || l.setData("text", a.id), i.currentDragItem = a, i.dateSelectionOrigin = void 0, n("drag-start", a, o), !0) : !1;
    }, j = (a) => a <= i.dateSelectionOrigin ? [a, i.dateSelectionOrigin] : [i.dateSelectionOrigin, a], Me = (a, o) => {
      t.enableDragDrop && n("drag-over-date", i.currentDragItem, a, o);
    }, ke = (a, o) => {
      if (t.enableDateSelection && i.dateSelectionOrigin && n("date-selection", j(a), o), !t.enableDragDrop)
        return;
      n("drag-enter-date", i.currentDragItem, a, o), o.target.classList.add("draghover");
    }, Ie = (a, o) => {
      if (t.enableDateSelection && t.selectionStart || !t.enableDragDrop)
        return;
      n("drag-leave-date", i.currentDragItem, a, o), o.target.classList.remove("draghover");
    }, Ce = (a, o) => {
      if (t.enableDateSelection && i.dateSelectionOrigin) {
        n("date-selection-finish", j(a), o);
        return;
      }
      if (!t.enableDragDrop)
        return;
      n("drop-on-date", i.currentDragItem, a, o), o.target.classList.remove("draghover");
    }, Oe = (a, o) => a.startDate < o.startDate ? -1 : o.startDate < a.startDate ? 1 : a.endDate > o.endDate ? -1 : o.endDate > a.endDate ? 1 : a.id < o.id ? -1 : 1, Se = (a) => ee(a, r.addDays(a, 6)), ee = (a, o) => V.value.filter((l) => l.endDate >= a && r.dateOnly(l.startDate) <= o, this).sort(Oe), Le = (a) => !!V.value.find((o) => o.endDate >= a && r.dateOnly(o.startDate) <= a), te = (a) => !(!t.selectionStart || !t.selectionEnd || a < r.dateOnly(t.selectionStart) || a > r.dateOnly(t.selectionEnd)), ae = (a) => {
      const o = Se(a), l = [], f = [[], [], [], [], [], [], []];
      if (!o)
        return l;
      for (let s = 0; s < o.length; s++) {
        const d = Object.assign({}, o[s], {
          classes: [...o[s].classes],
          itemRow: 0
        }), p = d.startDate < a, T = p ? 0 : r.dayDiff(a, d.startDate), re = Math.min(7 - T, r.dayDiff(r.addDays(a, T), d.endDate) + 1);
        p && d.classes.push("continued"), r.dayDiff(a, d.endDate) > 6 && d.classes.push("toBeContinued"), r.isInPast(d.endDate) && d.classes.push("past"), d.originalItem.url && d.classes.push("hasUrl");
        for (let I = 0; I < 7; I++)
          if (I === T) {
            let B = 0;
            for (; f[I][B]; )
              B++;
            d.itemRow = B, f[I][B] = !0;
          } else
            I < T + re && (f[I][d.itemRow] = !0);
        d.classes.push(`offset${T}`), d.classes.push(`span${re}`), l.push(d);
      }
      return l;
    }, Fe = (a) => {
      const o = '<span class="startTime">' + r.formattedTime(a.startDate, c.value, t.timeFormatOptions) + "</span>";
      let l = "";
      return r.isSameDateTime(a.startDate, a.endDate) || (l = '<span class="endTime">' + r.formattedTime(a.endDate, c.value, t.timeFormatOptions) + "</span>"), o + l;
    }, ne = (a) => t.showTimes ? Fe(a) + " " + a.title : a.title, N = (a) => {
      const o = a.itemRow, l = t.itemContentHeight, f = t.itemBorderHeight;
      return `calc(${t.itemTop} + ${o}*${l} + ${o}*${f})`;
    };
    return (a, o) => (v(), h("div", {
      "aria-label": "Calendar",
      class: S([
        "cv-wrapper",
        `locale-${u(r).languageCode(u(c))}`,
        `locale-${u(c)}`,
        `y${u(D).getFullYear()}`,
        `m${u(r).paddedMonth(u(D))}`,
        `period-${e.displayPeriodUom}`,
        `periodCount-${e.displayPeriodCount}`,
        {
          past: u(r).isPastMonth(u(D)),
          future: u(r).isFutureMonth(u(D)),
          noIntl: !u(r).supportsIntl
        }
      ])
    }, [
      C(a.$slots, "header", { headerProps: u(he) }),
      y("div", nt, [
        e.displayWeekNumbers ? (v(), h("div", rt)) : se("", !0),
        (v(!0), h(A, null, w(u(me), (l, f) => C(a.$slots, "dayHeader", {
          index: $(f),
          label: l
        }, () => [
          (v(), h("div", {
            key: $(f),
            class: S([$(f), "cv-header-day"])
          }, M(l), 3))
        ])), 256))
      ]),
      y("div", {
        "aria-multiselectable": e.enableDateSelection,
        class: "cv-weeks"
      }, [
        (v(!0), h(A, null, w(u(fe), (l, f) => (v(), h("div", {
          key: `${f}-week`,
          class: S(["cv-week", `week${f + 1}`, `ws${u(r).isoYearMonthDay(l)}`])
        }, [
          e.displayWeekNumbers ? (v(), h("div", ot, [
            C(a.$slots, "weekNumber", {
              date: l,
              numberInYear: u(k) + f,
              numberInPeriod: f + 1
            }, () => [
              y("span", null, M(u(k) + f), 1)
            ])
          ])) : se("", !0),
          y("div", it, [
            (v(!0), h(A, null, w(u(r).daysOfWeek(l), (s, d) => (v(), h("div", {
              key: $(d),
              draggable: e.enableDateSelection,
              class: S([
                "cv-day",
                $(d),
                `d${u(r).isoYearMonthDay(s)}`,
                `d${u(r).isoMonthDay(s)}`,
                `d${u(r).paddedDay(s)}`,
                `instance${u(r).instanceOfMonth(s)}`,
                {
                  today: u(r).isSameDate(s, u(r).today()),
                  outsideOfMonth: !u(r).isSameMonth(s, u(b)),
                  past: u(r).isInPast(s),
                  future: u(r).isInFuture(s),
                  last: u(r).isLastDayOfMonth(s),
                  lastInstance: u(r).isLastInstanceOfMonth(s),
                  hasItems: Le(s),
                  selectionStart: u(r).isSameDate(s, e.selectionStart),
                  selectionEnd: u(r).isSameDate(s, e.selectionEnd)
                },
                ...e.dateClasses && e.dateClasses[u(r).isoYearMonthDay(s)] || []
              ]),
              "aria-grabbed": e.enableDateSelection ? te(s) : void 0,
              "aria-label": s.getDate().toString(),
              "aria-selected": te(s),
              "aria-dropeffect": e.enableDragDrop && i.currentDragItem ? "move" : e.enableDateSelection && i.dateSelectionOrigin ? "execute" : "none",
              onClick: (p) => ye(s, p),
              onDragstart: (p) => Pe(s, p),
              onDrop: P((p) => Ce(s, p), ["prevent"]),
              onDragover: P((p) => Me(s, p), ["prevent"]),
              onDragenter: P((p) => ke(s, p), ["prevent"]),
              onDragleave: P((p) => Ie(s, p), ["prevent"])
            }, [
              y("div", dt, M(s.getDate()), 1),
              C(a.$slots, "dayContent", { day: s })
            ], 42, lt))), 128)),
            t.enableHtmlTitles ? (v(!0), h(A, { key: 0 }, w(ae(l), (s) => C(a.$slots, "item", {
              value: s,
              weekStartDate: l,
              top: N(s)
            }, () => [
              (v(), h("div", {
                key: s.id,
                draggable: e.enableDragDrop,
                "aria-grabbed": e.enableDragDrop ? s == i.currentDragItem : void 0,
                class: S([s.classes, "cv-item"]),
                title: s.tooltip || s.title,
                style: oe(`top:${N(s)};${s.originalItem.style}`),
                onDragstart: (d) => _(s, d),
                onMouseenter: (d) => X(s, d),
                onMouseleave: (d) => Z(s, d),
                onClick: P((d) => K(s, d), ["stop"]),
                innerHTML: ne(s)
              }, null, 46, ut))
            ])), 256)) : (v(!0), h(A, { key: 1 }, w(ae(l), (s) => C(a.$slots, "item", {
              value: s,
              weekStartDate: l,
              top: N(s)
            }, () => [
              (v(), h("div", {
                key: s.id,
                draggable: e.enableDragDrop,
                "aria-grabbed": e.enableDragDrop ? s == i.currentDragItem : void 0,
                class: S([s.classes, "cv-item"]),
                title: s.tooltip || s.title,
                style: oe(`top:${N(s)};${s.originalItem.style}`),
                onDragstart: (d) => _(s, d),
                onMouseenter: (d) => X(s, d),
                onMouseleave: (d) => Z(s, d),
                onClick: P((d) => K(s, d), ["stop"])
              }, M(ne(s)), 47, ct)),
              le(" div> ")
            ])), 256))
          ])
        ], 2))), 128))
      ], 8, st)
    ], 2));
  }
});
const gt = { class: "cv-header" }, ft = { class: "cv-header-nav" }, mt = ["disabled"], Dt = ["disabled", "innerHTML"], pt = ["disabled"], vt = ["disabled"], ht = { class: "periodLabel" }, Mt = /* @__PURE__ */ ie({
  __name: "CalendarViewHeader",
  props: {
    headerProps: {
      type: Object,
      required: !0
    },
    previousYearLabel: { type: String, default: "<<" },
    previousPeriodLabel: { type: String, default: "<" },
    nextPeriodLabel: { type: String, default: ">" },
    nextYearLabel: { type: String, default: ">>" }
  },
  emits: ["input"],
  setup(e, { emit: n }) {
    const t = (i) => n("input", i);
    return (i, c) => (v(), h("div", gt, [
      y("div", ft, [
        y("button", {
          disabled: !e.headerProps.previousYear,
          class: "previousYear",
          "aria-label": "Previous Year",
          onClick: c[0] || (c[0] = P((b) => t(e.headerProps.previousYear), ["prevent"]))
        }, M(e.previousYearLabel), 9, mt),
        y("button", {
          disabled: !e.headerProps.previousPeriod,
          class: "previousPeriod",
          "aria-label": "Previous Period",
          onClick: c[1] || (c[1] = P((b) => t(e.headerProps.previousPeriod), ["prevent"])),
          innerHTML: e.previousPeriodLabel
        }, null, 8, Dt),
        y("button", {
          class: "currentPeriod",
          "aria-label": "Current Period",
          onClick: c[2] || (c[2] = P((b) => t(e.headerProps.currentPeriod), ["prevent"]))
        }, M(e.headerProps.currentPeriodLabel), 1),
        y("button", {
          disabled: !e.headerProps.nextPeriod,
          class: "nextPeriod",
          "aria-label": "Next Period",
          onClick: c[3] || (c[3] = P((b) => t(e.headerProps.nextPeriod), ["prevent"]))
        }, M(e.nextPeriodLabel), 9, pt),
        y("button", {
          disabled: !e.headerProps.nextYear,
          class: "nextYear",
          "aria-label": "Next Year",
          onClick: c[4] || (c[4] = P((b) => t(e.headerProps.nextYear), ["prevent"]))
        }, M(e.nextYearLabel), 9, vt)
      ]),
      y("div", ht, [
        C(i.$slots, "label", {}, () => [
          le(M(e.headerProps.periodLabel), 1)
        ])
      ])
    ]));
  }
});
export {
  r as CalendarMath,
  Pt as CalendarView,
  Mt as CalendarViewHeader
};
